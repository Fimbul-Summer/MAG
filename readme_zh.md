
# 简介
一个离散时间的事件演算框架


# 变量

变量完全决定了角色当前的状态。
包括性别、年龄、颜值、智力、家境、体质、快乐……
还有拥有的物品、具有的天赋等等。

# 事件
事件的前提由变量决定，并引发变量变化的结果，称为事件的后果。
事件可以有发生的概率。
事件的后果可以是相对值的增量变化（称为后果增量），也可以是绝对值的变化（称为后果替换）。

更复杂的情况下，一个事件可能根据变量的不同有多个可能的结果分支。
多个事件之间可以互补，此时构成事件分支。
多个事件可以按照顺序排列，此时构成事件序列。


# 动作
动作同样有前提，并具有相应的后果。
更复杂的情况下，动作可能有多种不同的后果，并且有对应的成功率。

动作允许带有参数。（这里已经变得有点像Inform7了）。
动作可以有多个参数，
多个参数将按照顺序提示用户输入。

参数可具有各种类型（整数、实数、布尔值、枚举值……）和取值范围。
参数的取值范围有两种：一种是有限可数的，以列表形式直接列出；另一种是无限的，需要用户手动输入（例如字符串、数字）


# 物品
物品分为主动和被动物品。主动物品需要被主动使用才能生效，被动物品不需要使用就能生效。
物品分为消耗品和非消耗品。 消耗品只会生效一次，非消耗品可以生效多次。
物品可能直接改变变量，也可能改变事件、动作的作用方式。

# 天赋
天赋可能直接改变变量，也可能改变事件、动作的作用方式。
天赋相当于高优先级的规则。




# 事件变量和分支
有时候，事件之间有依赖关系。例如，只有一年前救了一条狗，一年后它才可能搭救你。
这时候，需要引入一个特别的变量：事件变量，它表示某个事件已经发生。可能还需要一个变量，代表前置事件触发距离当前的年份/时间窗口。
多个连续或者不连续触发的小事件可以组块，构成连续事件/大事件。

另一个可能更好的设计是引入历史，历史是特殊的列表类型的变量。

# 规则引擎
规则引擎根据游戏当前状态，计算下一个时间步的状态，包括如下流程：
1. 筛选出符合条件的事件，随机选择其中的1个或几个。
2. 计算变量的变化。
3. 根据物品、天赋的特殊效果，重新校正。其中越高稀有度的物品/天赋的规则优先级越高。
4. 根据动作条件，列出玩家可执行的动作。


# 本体

假设玩家获得了“仙丹”，然后玩家遭遇了事件 “得了感冒“、”得了肺炎“、”得了癌症“、”得了梅毒“ ……都可以因为仙丹的存在而产生病愈的后续事件。如果分别为每个事件都写这些规则，那么之后加入新规则也要再写，很容易忘造成不一致（语言模型忘了）。所以需要进行抽象，抽象出一个概念，叫做患病。然后有语句： 得了梅毒 a 患病。以及有规则，类似于：

病愈 a Event;
    precedent 患病;
    condition 拥有仙丹.

还需要指定该规则的优先级应该比普通的得病的事件的规则的优先级更高。


## 属性抽出
    将布尔变量变成属性。
    例如 住在农村 和 住在城市 可以变成 住所属性的值。



# 时间机器
时间机器可以设计为一个模拟器，允许回溯历史状态或预测未来状态。通过保存游戏的快照（snapshot），可以快速恢复到某个时间点。
这不仅可以用于调试，还可以为玩家提供独特的玩法（如“重开”或“后悔药”）


# 语言模型
## 创建新实体
语言模型可以根据游戏进程需要，创建新的实体，包括物品、天赋、事件、动作等

## 属性的细化/反涌现
例如原本可能只有一个体质属性同时决定了角色的生死、战斗的胜负。现在可能需要分开成生命值、战斗力两个变量。
则需要指定如何由细粒度的属性计算粗粒度的属性。（涌现）
以及在细粒度属性未知而只有粗粒度属性的情况下，以什么样的概率分布生成细粒度属性（后验概率）。


# 语言模型谓词
例如特定角色受到特定物品的好感度变化，可以用语言模型谓词来估计。


# 地点？

地点可以关联角色和物品. 角色可以自发在地点之间移动，物品不行.
地点具有可达关系. 构成一个连通图.
地点可能会影响角色的属性，或者影响动作和事件。例如岩浆会致死。例如只有在水里才能划船或遭遇鲨鱼袭击。

# 故事？
故事是角色、地点、事件等等的一系列非随机的构造。比如侦探推理故事。