
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix : <http://semex.sigmanoise.com/r3/life-sim#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@prefix diff: <http://www.w3.org/2004/delta#>.
@prefix var: <http://www.w3.org/2000/10/swap/var#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .


# 一个完整的影响包括： scope where insert delete 概率值 描述
#  where insert delete 可以用状态新增、变量增量之类的简写成一个图
# 概率可以用括号表示
# 描述可以省略
[
    a :影响;
    :描述 "示例影响";
    :where {:self :心情 ?z. :self :体力 ?x. (?x 1) math:sum ?y};
    :insert {:self :心情 ?y};
    :delete {:self :心情 ?z};
    :prob 0.9;
].




# 概率分为 :不可能（0%）、:罕见（6.25）、:少见/偶尔（25）、:有时（50）、:常见(71)、:必然（100）. 默认是有时
:概率 :默认值 :有时.
:因果 :必须属性 :概率.

# 具有触发条件的首因事件可以作为事件链的开端
{?x a :首因事件} <= {?x a :事件. ?x :条件 ?y}.

:车祸
    a   :事件;
    :影响  [
        :语句新增 {:self :拥有天赋 :大智若愚};
        :概率 :罕见;
        :描述 "车祸撞到了头，你因祸得福。";
    ] ; 
.

:下雨
    a   :事件;
    :描述   "哗啦啦啦……天上下起了大雨";
    :条件  {};
    :后果  (:发洪水 :罕见);
.

:发洪水
    a   :事件;
    :描述   "铺天盖地的大洪水淹没了一切";
    #:前因   (:下雨  :罕见);  # 似然概率p(洪水｜下雨)还是后验概率p(下雨｜洪水)？
    :后果   (:欠收  :必然), (:被淹死 :有时);
    # :影响  ({:self :死亡  true} :有时); #将其抽出来变成一个可重用的事件:被淹死，以添加描述 "你被淹死了"
.

:死亡事件 :super-class :事件.

# 拥有影响的事件可以做为事件因果链的终点。
:被打死
    a   :死亡事件;
    :描述   "你被打死了";
    :变量替换  {:self :死亡  true} ;
.

# :变量替换 :domain :事件.
# :变量增量 :domain :事件.
# :语句新增 :domain :事件.
# :语句移除 :domain :事件.


# # 可以用下面的语法糖，也可以在py脚本或者推理器中进一步处理
# {?x :必然变量替换 ?y} => {?x :变量替换 (?y :必然)}.
# {?x :必然变量增量 ?y} => {?x :变量增量 (?y :必然)}.
# {?x :必然语句新增 ?y} => {?x :语句新增 (?y :必然)}.
# {?x :必然语句移除 ?y} => {?x :语句移除 (?y :必然)}.
# {?x :必然条件 ?y} => {?x :条件 (?y :必然)}.
# {?x :必然后果 ?y} => {?x :后果 (?y :必然)}.
# {?x :必然前因 ?y} => {?x :前因 (?y :必然)}.


:被淹死
    a   :死亡事件;
    :描述   "你被淹死了";
    :变量替换  {:self :死亡  true} ; # 没有说明概率的，就是必然的
.

:被烧死
    a   :死亡事件;
    :描述   "你被烧死了";
    :变量替换  {:self :死亡  true} ;
.
# 死亡事件如果太多，需要自动抽象出一个事件团，即能够接受死法作为参数的一般死亡事件。

# 前因和条件不一样。前因是另一个事件，条件是一个状态图。例如住在农村是丰收的条件不是前因。
# 同样，后果和影响不一样。后果是一个事件，影响是一个状态图。
[
    a   :因果;
    :前因   :洪水;
    :后果   :被淹死;
    :概率   :有时; # 条件概率
].
# 通过 条件、后果、以及因果来表述，三种方式是等价的。
# 三种方式最终被转化为后果的表示方式。 令两种只是语法糖。
{?x a :因果; :前因 ?x1; :后果 ?x2; :概率 ?x3} => {?x1 :后果  (?x2 ?x3)}.
{?x2 :前因    (?x1 ?x3) } => {?x1 :后果  (?x2 ?x3)}.
# 而后果可以视为用history表达的条件。从而统一所有表示方法。利用history还可以表示延迟触发的事件链。
{?x2 :条件 ({1 :历史快照   ?g. ?g  e:call {:世界 :当前事件  ?x1} } ?x3)} => {?x1 :后果 (?x2 ?x3)}.
# TODO 理论上，从对偶角度考虑，多个前因的概率计算方式和多个后果不同，是说必须这些原因都满足才会发生，概率数值表示必须程度。 必须和必然是对偶的。
# 因此，前因属性的概率值是一个事件之前发生了另一个事件的后验概率。例如，在已知丰收的情况下，家住农村的概率是多少？
# 利用这种方式可以表达那些必须要满足多个前因才能发生的后果事件。

:丰收
    a :事件;
    :描述 "今年大丰收，而且你家的菜也涨价了";
    :条件 ({:self :住在农村 true } :有时);
    :变量增量 {:self :家境 1};
.

:欠收
    a :事件;
    :描述 "今年发生了旱灾/洪水，你家颗粒无收";
    :条件 ({:self :住在农村 true } :有时);
    :变量增量 {:self :家境 -1};
    :互斥 :丰收;
.


# 事件的后果可以是另一个事件？
:出生 a  :事件;
    :描述 "你出生了！";
    :条件 {:self :年龄 0}; 
    :变量替换 {:self :年龄 1};
    :后果分支  #后果分支是一个列表，其中的事件视为互斥且互补（概率值被归一化）
        (
            [:变量替换 {:self :性别 :男}; :描述 "你是男孩"; ]  #不需要说明概率值0.5，因为会被当作必然事件然后自动归一
            [:变量替换 {:self :性别 :女}; :描述 "你是女孩"; ]
        )
.


:过去1年 a :事件;
    :描述 "过去了1年";
    :条件 {}; #总是会发生
    :变量增量 {:self :年龄 1. :世界 :年份 1};
.


:过去多年 a :事件;
    :参数 [id :过去的年份 :参数范围  {:过去的年份 log:rawType rdf:integer}];
    :描述 "过去了[[:过去的年份]]年";
    :变量增量 {:self :年龄 :过去的年份. :世界 :年份 :过去的年份};
.

# self作为参数。即所有人都可以患病
:得了肺炎 
    a :事件;
    :参数 :病人;
    :父事件 :患病;
    :条件 ({:病人 :体质 ?x. ?x math:lessThan 7. :病人 :家境 ?x. ?x math:lessThan 3.} :常见); #在贫穷的家庭中，孩子得肺炎是很常见的
    :变量增量 {:病人 :体质 -2};
.


[
    a :事件;
    :描述 "刚学会走路，你意外从桌子上跌落";
    :条件 ({:self :年龄 ?x. ?x math:lessThan 3. :self :当前动作 :走路 } :少见);
    :变量增量 {:self :体质 -2};
].


