
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix : <http://semex.sigmanoise.com/r3/life-sim#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@prefix diff: <http://www.w3.org/2004/delta#>.


:跳过
    a   :动作;
    :前提 true;
    :参数 ();
    :描述 "什么都不做";
.

:抛硬币
    a   :动作;
    :前提   true;
    :参数   ();
    :描述   "抛一枚硬币";
    :后果   {
            { (100) e:random ?x  } diff:insertion { ( {?x math:greaterThan 49} {:看到  :投掷结果 :正面} {:看到  :投掷结果 :反面} ) log:ifThenElseIn ?scope }
    };
.

# log:ifThenElseIn
:投掷结果 a :临时变量.

:加点
    a   :动作;
    :参数 (:加点属性 :加点数值); # 可以将具体动作看作类，则它的参数就是其slot，实例就是具体的动作实例。
    :前提   {:self :可分配点数 ?y. 
            ?y math:greaterThan 0 };
    # :后果 {
    #     {:当前动作 :加点属性 ?p; :加点数值 ?v. :self ?p ?v2. (?v ?v2) math:sum ?v3 } 
    #         diff:replacement {:self ?p ?v3};
    #         #diff:deletion {:self ?p ?v2.}.
    # }
.

{
    :当前动作 a :加点.
    :当前动作 :加点属性 ?prop.
    :当前动作 :加点数值 ?v. 
    :self ?prop ?v2.
    (?v2 ?v ) math:sum ?v3.
} => {
    :当前动作 :后果 
    {
        {:self ?prop ?v2 } diff:replacement {:self ?prop ?v3}
    }

    # 另一种设计： 计算动作实例的未完全ground的后果。
    # TODO 但是似乎math:sum在diff:repalcement中会匹配失败？ 
    # {
    #     {:self ?prop ?v2. (?v2 ?v) math:sum ?v3 } diff:replacement {:self ?prop ?v3}
    # }
}.


:选择天赋
    a   :动作;
    :参数   (:所选天赋);
    :前提   {:self  :可选天赋数 ?y. ?y math:greaterThan 0};
    :后果   {{:当前动作 :所选天赋 ?v  } 
            diff:insertion {:self :具有天赋 ?v}};
.

{ 
    ?SCOPE e:findall (
        ?x
        {?x a :天赋}
        ?y
    ) .
    (?y 3) :random-sample ?answer.
} => {:所选天赋 :取值范围 ?answer}.



# 动作的后果是一个diff图
# 理论上，应该是动作实例而不是动作类对应一个后果的diff图。因此应该使用规则，说明如何从动作类型和参数计算具体的动作实例的diff. 
# 下面计算的不是动作实例的后果，而是当前状态下的动作实例的后果。完全ground了。

{
    ?x a :动作;
        :后果替换 {?s ?p ?o}
} => {
        ?x :后果 
        {
            {?s ?prop ?v } diff:replacement {?s ?prop ?o}
        }
}.



# 对于无参数的动作类，动作实例的后果可以从类那里继承。
{
    :当前动作 a ?action.
    ?action :后果 ?y.
} => { :当前动作 :后果 ?y}.




:加点属性 :取值范围 (:智力 :颜值 :体质 :家境). # 取值范围相当于 k:range

{:self :可分配点数 ?y. ("当前可分配点数为" ?y ) string:concatenation ?message} => {:加点数值 :提示信息 ?message.}.

:加点数值 :取值范围 xsd:integer. # 取值范围，相当于 k:constr-range-belongs

#:加点点数 :取值约束条件 (?value {:self :可分配点数 ?y. ?value math:lessThan ?y}) # :取值约束条件 可以看作该动作类的 slot上的constraint
{
    :当前动作 a :加点. 
    :当前动作 :加点数值 ?value. 
    :self :可分配点数 ?y. 
    ?value math:greaterThan ?y. 
    :self :可分配点数 ?z.
    ("加点不能超出可分配点数。" "当前的可分配点数为" ?z ) string:concatenation ?reason.
} => {:执行动作 a :Failed; :reason ?reason}.

:吃 a :动作 ;
    :描述 "你吃下了<<object>>" ;
    :参数 (:吃的对象);
    :前提 {
        :self :拥有物品 ?object .
        ?object a :食物.
    } ;
    :后果 {
        {:当前动作 :吃的对象 ?v  } 
            diff:deletion {:self :拥有物品 ?v.}.
    }
.

{ ?SCOPE e:findall (
        ?value
        {:self :拥有物品 ?value. ?value a :食物}
        ?values
    ) 
} => {:吃的对象 :取值范围 ?values}. # 自动推出列表




:赠送
    a   :动作;
    :参数   (:赠送物 :赠送对象); #所有的参数都是临时变量。
    :前提   {:self  :拥有物品 :赠送物};
    :后果
        [
            :移除   {:self :拥有物品  :赠送物};
            :新增   {:赠送对象  :拥有物品  :赠送物};
        ]
.

:服用仙丹
    a   :动作;
    :描述 "你服下了仙丹";
    :前提 {:self :拥有物品 :仙丹 };
    :后果 
    {
        {:self :拥有状态 :患病 }
            diff:deletion {:self :拥有状态 :患病 }.
    },
    {
        {?scope e:fail {:self :拥有状态 :患病}. :self :体质 ?x. (?x 2) math:sum ?y }
            diff:replacement {:self :体质 ?y}.
    }
.

:揍ta
    a   :动作;
    :参数 (:揍的对象);
    :描述 "你狠狠地揍了ta一拳";
    :前提 {:self!:体质 math:largerThan 5};
    :后果 {
            { :当前动作 :揍的对象 ?obj. ?obj :体质 ?x. (?x 2) math:difference ?y } 
                diff:replacement {?obj :体质 ?y };
                #diff:deletion {?obj :体质 ?x }
        } 
.

{?scope e:findall (?x {:self :认识的人 ?x} ?y)} => {:揍的对象 :取值范围 ?y}.

{?x a :动作. ?x :参数 ?l. ?y list:in ?l. } => {?y a :动作参数}.





