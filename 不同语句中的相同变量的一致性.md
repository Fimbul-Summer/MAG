
想要实现的效果：

用inline的方式处理n3 patch，或者一个选择语句。

例如：

```
:myfind a :Findall;
    :select {?person ex:givenName "Alex"};
    :where {?person ex:familyName "Garcia"};
.

```
或者
```


:mypatch a solid:InsertDeletePatch;
    solid:where   { ?person ex:familyName "Garcia". };
    solid:inserts { ?person ex:givenName "Alex". };
    solid:deletes { ?person ex:givenName "Claudia". }.


ex:pers001 ex:familyName "Garcia".
ex:pers001 ex:givenName "Claudia".
ex:pers002 ex:familyName "Cardinale".
ex:pers002 ex:givenName "Claudia".


{

    ?rename a solid:InsertDeletePatch;
            solid:where ?where;
            solid:inserts ?inserts;
            solid:deletes ?deletes.
    "T0" log:trace ( ?where ?inserts ?deletes) .
    ?where log:callWithCleanup true.
    ?deletes log:becomes ?inserts.
} => true.

```

0. 标准做法
在单独文件中用CONSTRUCT 和WHERE语句写sparql查询。
使用--sparql-query处理这种查询。

在单独文件中写n3 patch。
用semantics处理patch。

1. 用var:x来表示变量

e:labelvars 的作用是单向的，无法将var:x 变成 ?x.

```
{{?x :q {?x :p :o}} e:labelvars ?y} => {:anwer :is ?y}.
```


2. inline的处理

```
对于形如 

{} diff:insertion {};
    diff:deletion {}.

```
这样的语句，在用变量绑定这些引用图的时候，能保证不同引用图中的变量的名字的一致性。例如
```
{?x diff:insertion ?y; diff:deletion ?z. } => {:anwer :is (?x ?y ?z)}.

```

但是对于这样的语句不行,引用图中的同名变量被重新命名为不同变量了。
```
:mypatch
    solid:where {};
    solid:inserts {};
    solid:deletes

```


patchAsN3无法正确地将字符串中的 ?x 变成变量，而是变成了空白节点
```
{"@prefix ns1: <http://semex.sigmanoise.com/r3/life-sim#> .@forAll ns1:x. \n\n ns1:x ns1:p ns1:o .\n\n\n" log:parsedAsN3 ?y} => {:answer2 :is ?y}.

```
此时必须采用


Log:semantics可以保证在不同三元组中的引用图中相同变量的一致性。
但是直接的方法不行。
